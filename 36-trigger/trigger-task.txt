1. Выгрузите настройку (пиктограмма "гаечный ключ") таблицы person из БД test.
Добавьте в нее столбец ASalary(Годовая зарплата) с типом данных INT и ограничением UNSIGNED.
Нажмите APPLY для добавления столбца в таблицу.
2. Выгрузите таблицу person - и добавьте в выгрузку  пару записей (к примеру, 2 записи с идентификаторами ID 4 и 5 - не забываем, что идентификатор ID не должен повторяться).
Столбец  ASalary заполните вручную  - цифрами, как зарплата (Salary) умножить на 12. К пример, в строке где Salary=100.000, в столбце ASalary ставим 1.200.000 (=100.000*12).
Нажмите APPLY (apply-finish), чтобы изменения внеслись в таблицу.

3. Согласитесь, было бы неплохо при добавлении новой строки перед сохранением данных в БД автоматически для столбца ASalary делать вычисление Salary*12. Т.е., чтобы в ASalary автоматически подставлялось значение Salary*12 - ведь тогда даже если будет внесено несоответствующее значение, то его заменит на значение  Salary*12.
Так мы защитим себя от "человеческих ошибок" ввода данных; и более того - автоматизируем ввод этих данных, поскольку даже не заполняя ASalary (оставляя там null) при добавлении новой строки выполнится автоматический расчет и заполнение этого столбца.
Давайте напишем такой триггер:
- перейдите в настройки  (пиктограмма "гаечный ключ") таблицы person - Вам откроется окно настроек (1)
- перейдите на закладку TRIGGERS (2)
- нажмите возле BEFORE INSERT значок "+" для добавления шаблона кода триггера (3).
- поставьте курсор между BEGIN и END - и запишите выражение ASalary = Salary*12, а потом перед ASalary и Salary поставьте NEW (новое) с точкой, закрыв окончание формулы  точкой с запятой (4).

Подсказка: NEW.ASalary = NEW.Salary*12; 
- нажмите APPLY (5) (apply->finish) - и убедитесь что созданный триггер появился в таблице person в папке Triggers в окне НАВИГАТОРа (6)


4. Изучите конструкцию\синтаксис триггера: 
CREATE TRIGGER `person_BEFORE_INSERT`- создание  триггера c  именем\названием (название может быть любым, как и название столбца, таблицы и т.д.)
вставка DEFINER=`root`@`locathost` (до APPLY триггера там было DEFINER=CURRENT_USER, что означает текущий пользователь) - определение пользователя  (меня\Вас). Кстати, его на SQL писать не обязательно, оно по умолчанию в триггер потом само добавится.
BEFORE INSERT ON `person` - указывает что триггер ставится ПЕРЕД ВНЕСЕНИЕМ ИЗМЕНЕНИЙ в таблицу person
FOR EACH ROW - для каждой строки (т.е., вычисление делать по каждой строке столбца)
BEGIN...END - начало и конец, но кстати в SQL также писать не обязательно.

SET - установить
NEW.ASalary=NEW.Salary*12 - NEW означает новое значение  (т.е., получив новую Salary мы высчитываем новую ASalary, которую и загрузим в БД).

5. Проверьте работоспособность триггера: 
- выгрузите таблицу person - и в выгрузку внесите 3 записи\строки (допустим, с идентификаторами ID 6, 7 и 8, если они у Вас не повторяются): 
          в ID 6 по столбцу Salary поставьте 200.000, а по столбцу ASalary 1.000.000 (что не соответствует  Salary *12)

          в ID 7 по столбцу Salary поставьте 300.000, а по столбцу ASalary 3.600.000 (что соответствует  Salary *12)

          в ID 8 по столбцу Salary поставьте 400.000, а по столбцу ASalary оставьте пусто\null (хотя тут должно было бы быть 4.800.000)
- нажмите APPLY (apply->finish) - и убедитесь, что триггер все пересчитал корректно (для 6 значение 1.000.000 сменил на 2.400.000; для 7 поставил те же 3.600.000; для 8 которая была null - вычислил заполнил значением 4.800.000)

5. Теперь попробуем написать триггер на SQL с нуля, не прибегая к пользовательскому интерфейсу.
Обратите внимание на столбец Salary. Мы хотели бы перед внесением в БД автоматически вычислять\проверять соответствует ли зарплата минимуму МРОТ (минимальный размер оплаты труда, который составляет 19242 рубля) - и если нет, то подставлять минимальную сумму МРОТ. Тут логическая функция IF (ЕСЛИ): если Salary более или равно МРОТ - то ставить Salary, иначе - МРОТ.
Пишем такой триггер: 
- открываем пустой\новый SQL
- пишем команду на создание триггера CREATE TRIGGER, после которой даем название\имя триггера (имя может быть любое, но надо называть так чтобы самим понимать с названия что этот триггер делает: например, перед_изменением_зарплаты
 - далее команда "перед изменением какой таблицы" BEFORE INSERT ON person
- потом даем установку формулы:  SET NEW.Salary=IF(NEW.Salary>=19242,NEW.Salary,19242)
Запускаем скрипт  - и убеждаемся, что триггер появился в таблице person:
-  и в папке TRIGGERS в НАВИГАТОРЕ,
- и на вкладке  TRIGGERS в окне настроек таблицы person

Подсказка:

CREATE TRIGGER перед_изменением_зарплаты
BEFORE INSERT ON person
FOR EACH ROW
SET NEW.Salary=IF(NEW.Salary>=19242, NEW.Salary, 19242) 

6. Проверим его работоспособность: 

- выгрузите таблицу person - и в выгрузку внесите 3 записи\строки (допустим, с идентификаторами ID 9,10 и 11, если они у Вас не повторяются): 
          в ID 9 по столбцу Salary поставьте 20.000 (это больше МРОТ)

          в ID 10 по столбцу Salary поставьте 19.242 (это равно МРОТ)

          в ID 11  по столбцу Salary поставьте 10.000 (меньше МРОТ)

По столбца ASalary оставьте все пустым\null - проверите как отработают оба триггера вместе. 
- нажмите APPLY (apply->finish)
Убедитесь, что триггер все пересчитал корректно (для 9  остались 20.000 и 19.242 как соотв. условию >= МРОТ, а для 11  поставил 19.242).
А вот триггер  рассчитывающий годовую зарплату в столбце ASalary использовал также внесенные пользователем данные, а не пересчитанные триггером "перед_изменением_зарплаты" (к примеру, в ID 11 мы видим 120.000 - это 10.000 *12). И это важный момент: каждый такой простой триггер действует с ВНЕСЕННЫМ ЗНАЧЕНИЕМ перед его  добавлением в базу самостоятельно, НЕ во взаимодействии или в какой-то последовательности с другими триггерами. Поэтому как бизнес-пользователь хорошо думайте, что Вам нужно получить: и возможно стоит все вычисления запихать в один триггер, скомбинировав его формулу (а что-то возможно стоит перенести совсем на другие ограничения\проверки данных).

***
***
***

Вы уловили общую логику установки и работы триггеров? 

Думаю с установкой проблем нет, особенно если пользоваться пользовательским интерфейсом: 

1) в окне настроек таблицы на вкладке TRIGGERS выбрать ДО\ПОСЛЕ (BEFORE\AFTER) какого действия INSERT\UPDATE\DELETE должен срабатывать триггер

2) и прописать между BEGIN...END нужную формулу, которая должна автоматически запускаться при возникновении указанного действия (BEFORE\AFTER INSERT\UPDATE\DELETE ) в таблице. 



SQL-синтаксис триггера также не сложный: 

CREATE TRIGGER название

BEFORE INSERT ON таблица (вместо BEFORE (до) может быть AFTER (после), вместо INSERT (внести, добавить) может быть DELETE (удалить) или UPDATE (изменить))

FOR EACH ROW

SET формула (причем в формуле перед столбцами ставим NEW.)



Ну и логику работы  (да и собственно предназначение) триггеров наверняка уловили: каждый триггер автоматически запускает заданные в формуле вычисления в таблице ДО\ПОСЛЕ (BEFORE\AFTER) наступления событий  внесения новых (INSERT), либо изменения (UPDATE) или удаления (DELETE) существующих в таблице данных.

Если бы МРОТ находится в отдельной таблице (одно значение в столбце) - как (с помощью чего) Вы бы переписали формулу триггера так, чтобы забирать МРОТ из такой таблицы? 

Тогда Вы бы формуле триггера вытащили  МРОТ из другой таблицы с помощью подзапроса. Тогда Ваша формула для триггера могла бы выглядеть так:  SET NEW.Salary=IF(NEW.Salary>=(SELECT avg(МРОТ) FROM таблица),NEW.Salary,19242), где таблица  - таблица с МРОТ, а МРОТ - столбец содержащий значение МРОТ.

Можно ли было бы обеспечить соответствие значений столбца Salary МРОТ не прибегая к установке триггеров? Почему да\нет? 

Конечно можно: достаточно было поставить ограничение CHECK на столбец Salary>=19242.

Чисто для расширения кругозора о взаимодействии ограничений друг с другом сделаю ремарку: если на столбце будет стоять триггер, который меняет МРОТ ДО внесения изменений в БД (BEFORE INSERT), то CHECK уже будет работать с цифрой переделанной триггером, поскольку ограничение CHECK срабатывает в момент самого INSERT\внесения записи в БД.

А вот без триггера - CHECK не будет позволять вносить число менее 19.242.

Кто хочет проверить это взаимодействие, поставьте на столбец Salary соотв. проверку CHECK. Для установления проверки можете просто скопировать и запустить SQL-код ниже (он касается темы модификации таблиц и столбцов, о чем мы будем говорить в следующей лекции этого раздела по DDL)

ALTER TABLE person

MODIFY COLUMN Salary INT UNSIGNED CHECK(Salary>=19242)

После установки CHECK на столбец Salary у Вас одновременно будет стоять и триггер (BEFORE INSERT), и это ограничение. И если Вы внесете в таблицу новую строку со значением Salary менее МРОТ - то CHECK не выдаст никаких предупреждений. Это будет потому что ПЕРЕД тем как подать данные на внесение в БД (и собственно проверку CHECK'ом) запустится триггер (он же у нас ПЕРЕД!) и заменит значение МРОТа на минимальное, которое потом спокойно пропустит CHECK.

А если Вы удалите триггер (из окна настройки таблицы на вкладке Triggers) - то CHECK при попытке вносить новые строки со значением Salary менее МРОТ не будет это просто  пропускать. 