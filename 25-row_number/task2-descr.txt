--- У Вас столбцы, вычисленные функциями row_number, rank и dense_rank, показывают одинаковые значения в пределах окон.

--- А можете сказать есть ли разница между этими функциями? Если ДА, то какая именно? 

Столбцы показывают одинаковые значения потому, что в данном случае в строках в пределах окон нет ПОВТОРЯЮЩИХСЯ значений:  на таких масштабах оборотов магазинов вряд ли в конкретном месяце даже у 2-х магазинов суммы совпадут до рубля.

Все эти функции определяют порядковой место строки, начиная с номера 1. Но при это у них есть фундаментальные отличия:

- row_number просто тупо нумерует строки по порядку (если не отсортировать строки по какому-то критерию, то их просто пронумерует в том порядке, в котором они содержатся в БД)

- rank присваивает ранг. Причем если строки имеют одинаковое значение по критерию\столбцу сортировки - то все они получают одинаковый номер\ранг. Но нумерация следующей строки с другим значением будет начинаться с ее собственного номера строки, а не продолжаться с номера на котором закончился ранг предыдущей строки. Другими словами образно можно сказать: эта функция сначала нумерует строки как и row_number, а потом строкам с одинаковыми значениями по критерию сортировки ставит значение\номер, которое содержится в первой строке с таким значением.

-  dense_rank - это привычное нам "место" или рейтинг. Когда строки с одинаковыми значениями делят одно и то же место - и непрерывный\последовательный порядок (1,2,3....) нумерации мест сохраняется.   

--- Для чего предназначены и чем между собой отличаются функции cume_dist и percent_rank?

По сути они обе предназначения для вычисления % ранга (т.е., присваивают строкам %-е значение).

Но  percent_rank первой строке в окне ставит 0%, а cume_dist учитывает и первую строку для вычисления накопительного %.

Функция NTILE ближе к dense_rank и rank ИЛИ cume_dist и percent_rank? Почему Вы так считаете? 

Однозначно NTILE ближе к dense_rank и rank  поскольку присваивает не %, а абсолютный\числовой ранг (причем она намного ближе к dense_rank, так как присваивает непрерывные\последовательные ранги). Просто она присваивает одинаковый ранг ГРУППЕ строк, а не каждой отдельно.

Ну и важно помнить, что эта функция единственная из всех рейтинговых неагрегационных оконных функций требует указать  в скобках в качестве аргумента количество групп для разбиения на ранги (например, NTILE(5) означает что строки нужно разбить на 5 групп) 

--- У Вас получилось написать такой комплексный SQL-код, вычисляющий в одной выгрузке все  рейтинговые функции? 

Полагаю да: если не самостоятельно, то подсказки помогли. Но если кто-то хочет свериться - то загрузите приложенный SQL-скрипт, откройте его в Workbench и сверьтесь с Вашим кодом.

--- А можете сказать, что будет если использовать данные функции без over()? 

Ничего не будет, точнее ошибка будет - поскольку данные функции существуют для БД только как оконное вычисление вместе с over().